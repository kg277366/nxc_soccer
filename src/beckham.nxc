/* 2012.04.19 */

#define PID_P		20
#define PID_I		40
#define PID_D		100


// CONSTRUCTION PARAMS
#define OUT_DRIVE_L	OUT_A
#define OUT_DRIVE_R	OUT_C
#define OUT_DRIVE	OUT_AC
#define MM_PER_TURN	137
#define TRACK_FRONT_MM	119



#define MM2DEG(x)	(360 * x / MM_PER_TURN)



// TYPES

typedef struct {
	int x, y;
	int heading;
} RobotPos;

typedef struct {
	int x, y;
	int vx, vy;
} BallPos;

typedef struct {
	int compass;
	int ball_ir;
} SensorsValues;


// GLOBAL VARIABLES

RobotPos myPos, destPos;
BallPos ballPos;
SensorsValues sensorsValues;

// MUTEX
mutex moveMutex;

void init() {

}

void calibration() {

}

task move() {
	while(1) {
		Acquire(moveMutex);
		Release(moveMutex);
	}
}

task AI() {

}

task readSensors() {

}

task counter() {
     int i = 1 * 1000 * 1000;
     unsigned int cpu, cur, max, a, b;
     a = CurrentTick();
     while (i--);
     b = CurrentTick();
     max = b - a;
     while (1) {
           i = 1 * 1000 * 1000;
           a = CurrentTick();
           while (i--);
           b = CurrentTick();
           cur = b - a;
           if (cur < max)
              cur = max;
           cpu = 100 * (max) / cur;
           TextOut(0, LCD_LINE1, "CPU1:              ");
           if (cpu <= 100)
              NumOut(30, LCD_LINE1, cpu);
           else
               TextOut(30, LCD_LINE1, "??");
           TextOut(50, LCD_LINE1, "%");
     }
}
task counter2() {
     int i = 1 * 1000 * 1000;
     unsigned int cpu, cur, max, a, b;
     Wait(2000);
     a = CurrentTick();
     while (i--);
     b = CurrentTick();
     max = b - a;
     while (1) {
           i = 1 * 1000 * 1000;
           a = CurrentTick();
           while (i--);
           b = CurrentTick();
           cur = b - a;
           if (cur < max)
              cur = max;
           cpu = 100 * (max) / cur;
           TextOut(0, LCD_LINE2, "CPU2:              ");
           if (cpu <= 100)
              NumOut(30, LCD_LINE2, cpu);
           else
               TextOut(30, LCD_LINE2, "??");
           TextOut(50, LCD_LINE2, "%");
     }
}

task test() {
     Wait(4000);
     while (1) {
           byte outputs[2] = {OUT_DRIVE_L, OUT_DRIVE_R};
           char power = 75;
           byte reset = RESET_NONE;
           // 500 mm ahead
           RotateMotorExPID(outputs, power, MM2DEG(500), 0, true, true, PID_P, PID_I, PID_D);
           //Wait(1000);
           // 180 deg
           //RotateMotorExPID(outputs, power, MM2DEG(PI * TRACK_FRONT_MM / 2), 25, true, true, PID_P, PID_I, PID_D);
           RotateMotorPID(OUT_DRIVE_R, power, MM2DEG(PI * TRACK_FRONT_MM / 1), PID_P, PID_I, PID_D);
           ResetAllTachoCounts(outputs);
           //Wait(1000);
           // 500 mm back
           RotateMotorExPID(outputs, power, MM2DEG(500), 0, true, true, PID_P, PID_I, PID_D);
           //Wait(1000);
           // 90 deg in place
           RotateMotorExPID(outputs, power, MM2DEG(PI * TRACK_FRONT_MM / 4), 100, true, true, PID_P, PID_I, PID_D);
           //Wait(1000);
           // D ahead
           RotateMotorExPID(outputs, power, MM2DEG(TRACK_FRONT_MM), 0, true, true, PID_P, PID_I, PID_D);
           //Wait(1000);
           // 90 deg in place
           RotateMotorExPID(outputs, power, MM2DEG(PI * TRACK_FRONT_MM / 4), 100, true, true, PID_P, PID_I, PID_D);
           Wait(10000);
     }
}

task main() {
	//init();
	//calibration();
	
	//Precedes(readSensors, AI, move);
	Precedes(counter, counter2, test);
}





