/* 2012.04.19 */

#include "sin256.h"

#define PID_P		20
#define PID_I		40
#define PID_D		100


// CONSTRUCTION PARAMS
#define OUT_DRIVE_L	OUT_A
#define OUT_DRIVE_R	OUT_C
#define OUT_DRIVE	OUT_AC
#define OUT_KICK	OUT_B
#define MM_PER_TURN	137
#define TRACK_FRONT_MM	119
#define COMPASS_ACC 5
#define FIELD_W 1200
#define FIELD_H 1800
#define POS_ACC 50
#define BALL_DEF_DIST 1000
#define IN_POS_ACC 20

// SENSORS
#define ULTRASONIC IN_2
#define COMPASS IN_1
#define IR_SEEKER IN_4

#define MM2DEG(x)	(360 * x / MM_PER_TURN)

#define Q_SIZE 4;

#define TextNumOut(xPos,yPos,str,col,num) TextOut(xPos,yPos,str); \
	NumOut(xPos+6*col,yPos,num)


// TYPES

typedef struct {
	int x, y;
	int heading;
} RobotPos;

typedef struct {
	int x, y;
	int vx, vy;
} BallPos;

typedef struct {
	int compass;
	int ir_ball;
	int ir_dir;
	int distance;
} SensorsValues;

// QUEUE

typedef struct {
	int beg, end;
	RobotPos steps[Q_SIZE];
} Queue;

void qGet(Queue &q, RobotPos &res) {
	res = q.steps[q.beg];
	q.beg = (q.beg + 1) % Q_SIZE;
}

void qPut(Queue &q, RobotPos &pos) {
	q.steps[q.end] = pos;
	q.end = (q.end + 1) % Q_SIZE;
}

inline void qPeek(Queue &q, RobotPos &res) {
	res = q.steps[q.beg];
}

inline int qEmpty(Queue &q) {
	return q.beg == q.end;
}

// GLOBAL VARIABLES
int north;
RobotPos myPos, destPos;
BallPos ballPos;
SensorsValues sensorsValues;
//Queue queue;

// MUTEX
mutex moveMutex;

// Movement utilities
#include "mov.h"

void init() {
	MOV_init();
	SetSensorLowspeed(ULTRASONIC);
	SetSensorLowspeed(COMPASS);
	SetSensorLowspeed(IR_SEEKER);
}

void calibration() {

	north = SensorHTCompass(COMPASS);
	sensorsValues.compass = 0;


	Wait(500);
	myPos.y = FIELD_H - SensorUS(ULTRASONIC) * 10;
	rotate2w(90);
	Wait(500);
	myPos.x = FIELD_W - SensorUS(ULTRASONIC) * 10;
	rotate2w(-90);
	//Wait(2000);

	PlaySound(SOUND_DOUBLE_BEEP);

}

inline int onPosition() {
	return (destPos.x < 0 || (abs(destPos.x - myPos.x) < IN_POS_ACC
				&& abs(destPos.y - myPos.y) < IN_POS_ACC));
}

task move() {
	int x, y, dist, ro;
	/*while(1) {
	  Acquire(moveMutex);
	  if (onPosition()) { // Only rotation
	  rotate2w(destPos.heading - myPos.heading);
	  } else {
	  x = destPos.x - myPos.x;
	  y = destPos.y - myPos.y;
	  int deg = 3.14 * atan2(x, y) / 180;
	  roatate2w(destPos.heading - deg);
	  int dist = sqrt(x*x + y*y);
	  run(dist);
	  }
	  Release(moveMutex);
	  } */
}

task AI() {
	while(1) {
		destPos.x = 100;
		destPos.y = 50;
		destPos.heading = 50;
	} 
}

void findBall() {
	while (1) {
		int dir = sensorsValues.ir_dir;
		int power = ((dir - 5) * 75) / 5;

		if (dir != 5) {
			int lpower = -power;
			int rpower = power;
			OnFwd(OUT_DRIVE_L, lpower);
			OnFwd(OUT_DRIVE_R, rpower);
		}
		else {
			Off(OUT_DRIVE_L);
			Off(OUT_DRIVE_R);
			break;
		}
		Wait(20);
	}
}

int ai_state = 1;

#define SEARCH_S 1
#define SHOT_S 2

task ultraAI() {
  while (1) {
    Wait(1000);
    switch(ai_state) {
      case SEARCH_S :
		    findBall();
		    PlaySound(SOUND_DOUBLE_BEEP);
		    if (sensorsValues.distance > 250) {
			    run(10);
		    } else {
          ai_state = SHOT_S;        
		    }
      break;
      case SHOT_S :
        if (sensorsValues.compass < 90 || sensorsValues.compass > 270) {
          while(sensorsValues.distance > 30) {
            run(30);
          }
          kick();
          // do przodu
        } else {
          // do tylu
          int app = myPos.x > FIELD_W / 2 ? -1 : 1;
          
          rotate2w(app * 20);
          while(sensorsValues.distance > 30) {
            run(30);
          }
          rotate1w(-180 * app);
          kick();
        }
        ai_state = SEARCH_S;
      break;
	  }
  }
}

void sensorCompass() {
	sensorsValues.compass = SensorHTCompass(COMPASS) - north;
	myPos.heading = sensorsValues.compass;
}

void sensorUS() {

	sensorsValues.distance = SensorUS(ULTRASONIC) * 10;
	if ((sensorsValues.compass + COMPASS_ACC) % 90 < 2 * COMPASS_ACC) {
		int nY, nX;
		switch((sensorsValues.compass + COMPASS_ACC) / 90) {
			case 0 :
			case 4 :
				nY = FIELD_H - sensorsValues.distance;
				if (abs(nY - myPos.y) < POS_ACC) {
					myPos.y = nY;
				}
				break;
			case 2 :
				nY = sensorsValues.distance;
				if (abs(nY - myPos.y) < POS_ACC) {
					myPos.y = nY;
				}
				break;
			case 3 :
				nX = sensorsValues.distance;
				if (abs(nX - myPos.x) < POS_ACC) {
					myPos.x = nX;
				}
				break;
			case 1 :
				nX = FIELD_W - sensorsValues.distance;
				if (abs(nX - myPos.x) < POS_ACC) {
					myPos.x = nX;
				}
				break; //TODO ogarniamy czy to nie bedzie przeciwnik
		}
	}
}

void findBall2() {
	int ball_dist = sensorsValues.distance < BALL_DEF_DIST ?
		sensorsValues.distance : BALL_DEF_DIST;
	ballPos.x = myPos.x + (ball_dist * sin256(sensorsValues.ir_ball)) / 256;
	ballPos.y = myPos.y + (ball_dist * sin256(sensorsValues.ir_ball + 90)) / 256;
}

void sensorIR() {
	int dir;
	byte s1, s2, s3, s4, s5; //TODO policzyc z tego dokladniejsza wartosc
	bool result = ReadSensorHTIRSeeker2AC(IR_SEEKER, dir, s1, s2, s3, s4, s5);
	sensorsValues.ir_ball = (myPos.heading + 30 * dir + 210) % 360;
	sensorsValues.ir_dir = dir;
}

task readSensors() {
	while(1) {
		unsigned int a, b;
		a = CurrentTick();


		sensorCompass();
		sensorUS();
		sensorIR();

		b = CurrentTick();

		TextNumOut(0, LCD_LINE1, "Compass:        ",9, sensorsValues.compass);
		TextNumOut(0, LCD_LINE2, "Time:           ",6, (b - a));
		TextNumOut(0, LCD_LINE3, "Dir:            ",5, sensorsValues.ir_ball);
		TextNumOut(0, LCD_LINE4, "Dist:           ",6, sensorsValues.distance);
		TextNumOut(0, LCD_LINE5, "X:              ",6, myPos.x);
		TextNumOut(0, LCD_LINE6, "Y:              ",6, myPos.y);

		Wait(100);
	}
}

task main() {
	init(); 
	calibration();
	Precedes(readSensors, ultraAI);//, AI, move);
}
